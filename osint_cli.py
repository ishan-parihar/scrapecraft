#!/usr/bin/env python3
"""
OSINT-OS Command Line Interface (CLI)

A comprehensive command-line tool for managing OSINT investigations
with project creation, research execution, and configuration management.
"""

import asyncio
import click
import json
import os
import sys
import uuid
import random
import string
import logging
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv
from typing import Optional, Dict, Any, List
import re


def setup_project_logging(project_path: Path):
    """Setup logging to write to the project's logs directory."""
    # Create logs directory if it doesn't exist
    logs_dir = project_path / 'logs'
    logs_dir.mkdir(exist_ok=True)
    
    # Create a log file with timestamp
    log_filename = logs_dir / f'investigation_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'
    
    # Remove existing handlers to avoid duplicate logs
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)
    
    # Configure logging to write to both file and console
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_filename),
            logging.StreamHandler(sys.stdout)
        ]
    )


def generate_topic_based_project_name(topic: str) -> str:
    """Generate a project name based on the investigation topic using AI-like parsing."""
    # Clean the topic for use in filename
    clean_topic = re.sub(r'[^\w\s-]', '', topic.lower())
    words = clean_topic.split()
    
    if not words:
        # Fallback to timestamp if no valid words found
        timestamp = datetime.now().strftime("%H%M%S")
        return f"investigation_{timestamp}_{''.join(random.choices(string.ascii_lowercase + string.digits, k=6))}"
    
    # Take first 2-3 significant words and create a slug
    slug_words = []
    for word in words[:3]:  # Take up to 3 words
        clean_word = re.sub(r'[^a-z0-9]', '', word)
        if clean_word and len(clean_word) > 2:  # Only include meaningful words
            slug_words.append(clean_word)
    
    if not slug_words:
        # If no significant words found, use a generic identifier with timestamp
        timestamp = datetime.now().strftime("%H%M%S")
        return f"investigation_{timestamp}_{''.join(random.choices(string.ascii_lowercase + string.digits, k=6))}"
    
    # Join the words and add a hex suffix for uniqueness
    base_name = "_".join(slug_words)
    hex_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=6))
    
    return f"investigation_{base_name}_{hex_suffix}"


def validate_project_name(project_name: str) -> bool:
    """Validate if a project name is already taken in the current directory."""
    project_path = Path(project_name)
    return not project_path.exists()


def generate_unique_project_name(topic: str) -> str:
    """Generate a unique project name based on the topic that doesn't already exist."""
    max_attempts = 100
    for _ in range(max_attempts):
        name = generate_topic_based_project_name(topic)
        if validate_project_name(name):
            return name
    
    # If we can't find a unique name after max_attempts, add a timestamp
    timestamp = datetime.now().strftime("%H%M%S")
    return f"investigation_{timestamp}_{''.join(random.choices(string.ascii_lowercase + string.digits, k=4))}"


def create_project_structure(project_path: Path, topic: str = "") -> None:
    """Create the project directory structure."""
    directories = ['data', 'docs', 'logs', 'outputs']
    
    for directory in directories:
        (project_path / directory).mkdir(parents=True, exist_ok=True)
    
    # Create initial config file
    config_data = {
        "project_id": str(uuid.uuid4()),
        "created_at": datetime.now().isoformat(),
        "status": "initialized",
        "investigation_topic": topic,
        "research_intensity": "standard",
        "output_format": "json"
    }
    
    with open(project_path / 'config.json', 'w') as f:
        json.dump(config_data, f, indent=2)
    
    # Create initial README
    readme_content = f"""# OSINT Investigation Project

**Operation ID:** `{project_path.name}`
**Created:** `{datetime.now().isoformat()}`
**Topic:** `{topic or "N/A"}`

## Description
This project was automatically generated for OSINT investigation of: {topic or "No specific topic"}

## Structure
- `data/` - Raw data collected during investigation
- `docs/` - Documentation and notes
- `logs/` - Investigation logs and audit trails
- `outputs/` - Final reports and outputs
- `config.json` - Project configuration

## Status
- **Status**: initialized
- **Research Intensity**: standard
- **Output Format**: json

## Investigation Topic
{topic or "[Not specified]"}

---
*Generated by OSINT-OS CLI*
"""
    
    with open(project_path / 'README.md', 'w') as f:
        f.write(readme_content)


@click.group()
@click.version_option(version='1.0.0')
@click.option('--config', '-c', type=click.Path(exists=True), help='Configuration file path')
def cli(config: Optional[str]) -> None:
    """OSINT-OS: Advanced OSINT Investigation Platform CLI."""
    if config:
        load_dotenv(config)
    else:
        # Try to load default .env file
        load_dotenv()


@cli.command()
@click.argument('topic', required=False)
@click.option('--intensity', '-i', 
              type=click.Choice(['basic', 'standard', 'comprehensive', 'deep']),
              default='standard',
              help='Research intensity level')
@click.option('--output', '-o',
              type=click.Choice(['json', 'markdown', 'both']),
              default='json',
              help='Output format')
@click.option('--project', '-p', 
              type=click.Path(exists=True),
              help='Existing project directory to use')
@click.option('--name', '-n',
              type=str,
              help='Custom project name')
def research(topic: Optional[str], intensity: str, output: str, project: Optional[str], name: Optional[str]) -> None:
    """Start a new research investigation."""
    if not topic:
        click.echo("Error: Missing argument 'TOPIC'.", err=True)
        return
    
    # Create project directory
    if not project:
        if name:
            project_name = name
            project_path = Path(project_name)
            if project_path.exists():
                click.echo(f"Error: Project directory '{project_name}' already exists.", err=True)
                return
        else:
            project_name = generate_unique_project_name(topic)
            project_path = Path(project_name)
        
        click.echo(f"Creating new project: {project_path}")
        create_project_structure(project_path, topic)
    else:
        project_path = Path(project)
        if not (project_path / 'config.json').exists():
            click.echo(f"Error: Invalid project directory {project_path} - missing config.json", err=True)
            return
    
    # Setup logging to project directory BEFORE initializing OSINT OS
    setup_project_logging(project_path)
    
    # Update configuration
    config_path = project_path / 'config.json'
    with open(config_path, 'r') as f:
        config_data = json.load(f)
    
    config_data.update({
        "investigation_topic": topic,
        "research_intensity": intensity,
        "output_format": output
    })
    
    with open(config_path, 'w') as f:
        json.dump(config_data, f, indent=2)
    
    try:
        # Import OSINTOperatingSystem only when needed to avoid circular imports
        from osint_os import OSINTOperatingSystem
        
        # Initialize OSINT Operating System
        osint_os = OSINTOperatingSystem()
        
        # Map intensity to priority
        priority_map = {
            'basic': 'low',
            'standard': 'medium', 
            'comprehensive': 'high',
            'deep': 'critical'
        }
        priority = priority_map.get(intensity, 'medium')
        
        # Initialize the system (this will use the project-specific logging now)
        asyncio.run(osint_os.initialize())
        
        # Run the investigation
        click.echo(f"Starting investigation: {topic}")
        click.echo(f"Intensity: {intensity} (Priority: {priority})")
        click.echo(f"Project: {project_path}")
        
        final_state = asyncio.run(osint_os.run_investigation(
            user_request=topic,
            investigation_id=config_data.get('project_id'),
            priority=priority
        ))
        
        # Update config with status
        config_data['status'] = 'completed'
        config_data['completed_at'] = datetime.now().isoformat()
        with open(config_path, 'w') as f:
            json.dump(config_data, f, indent=2)
        
        # Generate report based on output format
        if output in ['json', 'both']:
            json_report = asyncio.run(osint_os.generate_report('json'))
            json_path = project_path / 'outputs' / f'report_{config_data["project_id"]}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            with open(json_path, 'w') as f:
                f.write(json_report)
            click.echo(f"JSON report saved to: {json_path}")
        
        if output in ['markdown', 'both']:
            md_report = asyncio.run(osint_os.generate_report('text'))
            md_path = project_path / 'outputs' / f'report_{config_data["project_id"]}_{datetime.now().strftime("%Y%m%d_%H%M%S")}.md'
            with open(md_path, 'w') as f:
                f.write(md_report)
            click.echo(f"Markdown report saved to: {md_path}")
            
        click.echo("\nInvestigation completed successfully!")
        
    except KeyboardInterrupt:
        click.echo("\nInvestigation interrupted by user")
        if 'osint_os' in locals() and osint_os.state:
            save_path = project_path / 'outputs' / f'state_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            osint_os.save_state(str(save_path))
            click.echo(f"Current state saved to: {save_path}")
    except Exception as e:
        click.echo(f"Error during investigation: {str(e)}", err=True)
        import traceback
        traceback.print_exc()


@cli.command()
@click.option('--intensity', '-i', 
              type=click.Choice(['basic', 'standard', 'comprehensive', 'deep']),
              default='standard',
              help='Default research intensity level')
@click.option('--output', '-o',
              type=click.Choice(['json', 'markdown', 'both']),
              default='json',
              help='Default output format')
@click.option('--name', '-n',
              type=str,
              help='Custom project name')
@click.argument('topic', required=True)
def setup(topic: str, name: Optional[str], intensity: str, output: str) -> None:
    """Create a new project with default settings for a specific topic."""
    if name:
        project_name = name
        project_path = Path(project_name)
        if project_path.exists():
            click.echo(f"Error: Project directory '{project_name}' already exists.", err=True)
            return
    else:
        project_name = generate_unique_project_name(topic)
        project_path = Path(project_name)
    
    click.echo(f"Creating new project: {project_path}")
    create_project_structure(project_path, topic)
    
    # Update configuration
    config_path = project_path / 'config.json'
    with open(config_path, 'r') as f:
        config_data = json.load(f)
    
    config_data.update({
        "investigation_topic": topic,
        "research_intensity": intensity,
        "output_format": output,
        "status": "setup"
    })
    
    with open(config_path, 'w') as f:
        json.dump(config_data, f, indent=2)
    
    click.echo(f"Project '{project_name}' created successfully in {project_path.absolute()}")
    click.echo(f"Configuration: intensity={intensity}, output={output}, topic={topic}")


@cli.command()
def projects() -> None:
    """List all OSINT projects in the current directory."""
    project_dirs = []
    for item in Path('.').iterdir():
        if item.is_dir() and (item.name.startswith('investigation_') or item.name.startswith('operation_')) and (item / 'config.json').exists():
            with open(item / 'config.json', 'r') as f:
                try:
                    config = json.load(f)
                    project_dirs.append({
                        'name': item.name,
                        'created': config.get('created_at', 'Unknown'),
                        'topic': config.get('investigation_topic', 'N/A'),
                        'status': config.get('status', 'Unknown')
                    })
                except json.JSONDecodeError:
                    # Skip invalid config files
                    continue
    
    if not project_dirs:
        click.echo("No OSINT projects found in current directory.")
        return
    
    click.echo(f"Found {len(project_dirs)} OSINT project(s):\n")
    for project in project_dirs:
        click.echo(f"📁 {project['name']}")
        click.echo(f"   Created: {project['created']}")
        click.echo(f"   Topic: {project['topic']}")
        click.echo(f"   Status: {project['status']}")
        click.echo()


@cli.command()
@click.argument('project_path', type=click.Path(exists=True))
def status(project_path: str) -> None:
    """Show the status of a specific project."""
    path = Path(project_path)
    
    if not (path / 'config.json').exists():
        click.echo(f"Error: Invalid project directory {project_path} - missing config.json", err=True)
        return
    
    with open(path / 'config.json', 'r') as f:
        config = json.load(f)
    
    click.echo(f"Project: {path.name}")
    click.echo(f"Created: {config.get('created_at', 'Unknown')}")
    click.echo(f"Status: {config.get('status', 'Unknown')}")
    click.echo(f"Topic: {config.get('investigation_topic', 'N/A')}")
    click.echo(f"Intensity: {config.get('research_intensity', 'standard')}")
    click.echo(f"Output: {config.get('output_format', 'json')}")
    
    # Count files in each directory
    data_count = len(list((path / 'data').glob('*')))
    docs_count = len(list((path / 'docs').glob('*')))
    logs_count = len(list((path / 'logs').glob('*')))
    outputs_count = len(list((path / 'outputs').glob('*')))
    
    click.echo(f"Data files: {data_count}")
    click.echo(f"Docs files: {data_count}")
    click.echo(f"Logs files: {logs_count}")
    click.echo(f"Outputs files: {outputs_count}")


@cli.command()
@click.option('--list', '-l', 'list_config', is_flag=True, help='List current configuration')
@click.option('--set', '-s', 'set_config', nargs=2, metavar='KEY VALUE', help='Set configuration value')
@click.option('--file', '-f', type=click.Path(exists=True), help='Configuration file to load')
def config(list_config: bool, set_config: Optional[tuple], file: Optional[str]) -> None:
    """Manage OSINT-OS configuration."""
    config_file = Path('.env')
    
    if file:
        # Load from specified file
        load_dotenv(file)
        click.echo(f"Configuration loaded from {file}")
        return
    
    if set_config:
        key, value = set_config
        # In a real implementation, you would update the .env file
        click.echo(f"Setting {key}={value}")
        click.echo("Note: Configuration setting not implemented in this version")
        return
    
    if list_config or not set_config:
        # List current configuration
        env_vars = dict(os.environ)
        osint_vars = {k: v for k, v in env_vars.items() if k.startswith('OSINT_') or k.startswith('OPEN') or k.startswith('LOCAL')}
        
        if osint_vars:
            click.echo("Current OSINT-OS Configuration:")
            for key, value in osint_vars.items():
                click.echo(f"  {key}={value}")
        else:
            click.echo("No OSINT-OS environment variables set")
            if config_file.exists():
                click.echo(f"Configuration file {config_file} exists but no variables loaded")
            else:
                click.echo(f"No configuration file {config_file} found")


if __name__ == '__main__':
    cli()
